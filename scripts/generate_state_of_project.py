#!/usr/bin/env python3
"""
State of the Project Report Generator
=====================================
Generates a comprehensive "State of the Project" report from Swarm data sources
and posts it to Discord. Designed for 3 AM daily execution.

Usage:
    python3 scripts/generate_state_of_project.py [--dry-run]
"""

import os
import sys
import json
import yaml
import asyncio
import logging
import argparse
from pathlib import Path
from datetime import datetime

# Mock pyautogui to prevent display errors in headless environment
from unittest.mock import MagicMock
sys.modules["pyautogui"] = MagicMock()

# Add project root to path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

try:
    from src.discord_commander.discord_service import get_discord_service
except ImportError:
    # Fallback if src not in path
    sys.path.insert(0, os.getcwd())
    from src.discord_commander.discord_service import get_discord_service

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Mock pyautogui to prevent display errors in headless environment
from unittest.mock import MagicMock
sys.modules["pyautogui"] = MagicMock()

LORE_ROOT = Path("lore")
AGENTS_ROOT = Path("agent_workspaces")

def load_yaml(path):
    if not path.exists():
        return {}
    with open(path, "r") as f:
        return yaml.safe_load(f)

def load_json(path):
    if not path.exists():
        return {}
    with open(path, "r") as f:
        return json.load(f)

def get_world_state():
    return load_yaml(LORE_ROOT / "world_state.yaml")

def get_recent_episodes(limit=3):
    index = load_yaml(LORE_ROOT / "episodes/index.yaml")
    if not index or "episodes" not in index:
        return []
    return index["episodes"][:limit]

def get_agent_statuses():
    statuses = {}
    for agent_dir in AGENTS_ROOT.glob("Agent-*"):
        status_file = agent_dir / "status.json"
        if status_file.exists():
            try:
                data = load_json(status_file)
                statuses[agent_dir.name] = {
                    "status": data.get("status", "UNKNOWN"),
                    "current_task": data.get("current_task", "None"),
                    "last_updated": data.get("last_updated", "Unknown")
                }
            except Exception as e:
                logger.error(f"Error reading status for {agent_dir.name}: {e}")
    return statuses

def get_recent_closures():
    closures = []
    for agent_dir in AGENTS_ROOT.glob("Agent-*"):
        closure_dir = agent_dir / "session_closures"
        if closure_dir.exists():
            for closure_file in closure_dir.glob("*.md"):
                # Check modification time to see if recent (last 24h)
                mtime = closure_file.stat().st_mtime
                if (datetime.now().timestamp() - mtime) < 86400:
                    closures.append({
                        "agent": agent_dir.name,
                        "file": closure_file.name,
                        "path": str(closure_file)
                    })
    return closures

def generate_report_content():
    world = get_world_state()
    world_clock = world.get("world_state", {}).get("world_clock", {})
    quests = world.get("world_state", {}).get("active_quests", [])
    
    episodes = get_recent_episodes()
    agent_statuses = get_agent_statuses()
    recent_closures = get_recent_closures()
    
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    report = f"""# ðŸ“¡ STATE OF THE PROJECT: {datetime.now().strftime('%Y-%m-%d')}
**Time:** {timestamp}
**Cycle:** {world_clock.get('current_cycle', 'Unknown')} | **Phase:** {world_clock.get('phase', 'Unknown')}

## ðŸŒ World State
"""
    
    if quests:
        report += "**Active Quests:**\n"
        for quest in quests:
            report += f"- **{quest.get('title')}** ({quest.get('status')}): Owner {quest.get('owner')}\n"
    else:
        report += "*No active quests recorded in world state.*\n"

    report += "\n## ðŸ¤– Swarm Status\n"
    for agent, status in sorted(agent_statuses.items()):
        icon = "ðŸŸ¢" if status['status'] == "ACTIVE" or status['status'] == "ACTIVE_AGENT_MODE" else "ðŸŸ¡"
        report += f"- {icon} **{agent}**: {status['status']}\n"

    if recent_closures:
        report += "\n## ðŸ“ Recent Session Closures (Last 24h)\n"
        for closure in recent_closures:
            report += f"- **{closure['agent']}**: `{closure['file']}`\n"
    
    if episodes:
        report += "\n## ðŸ“œ Canon Episodes\n"
        for ep in episodes:
            report += f"- **{ep.get('date')}**: {ep.get('title')}\n"

    report += "\n---\n*Transmission auto-generated by Swarm Overseer Service*"
    return report

async def main():
    parser = argparse.ArgumentParser(description="Generate State of the Project Report")
    parser.add_argument("--dry-run", action="store_true", help="Print report to stdout instead of posting to Discord")
    args = parser.parse_args()

    report = generate_report_content()
    
    if args.dry_run:
        print(report)
        return

    logger.info("Generated report. Posting to Discord...")
    
    # Use DiscordService to post
    # Note: We need a channel ID or webhook URL. DiscordService uses webhook by default.
    # We can try to use the 'broadcast' feature or just send to general.
    
    service = get_discord_service()
    
    # Construct a payload that fits the 'coordination' format or just a generic message
    # DiscordService has send_swarm_coordination_notification which seems appropriate
    
    success = service.send_swarm_coordination_notification({
        "message": report,
        "title": "Daily State of the Project"
    })
    
    if success:
        logger.info("âœ… Report posted successfully.")
    else:
        logger.error("âŒ Failed to post report.")
        # Fallback print
        print("--- REPORT CONTENT (FALLBACK) ---")
        print(report)

if __name__ == "__main__":
    asyncio.run(main())
