#!/usr/bin/env python3
"""
Phase 2: Dependency Resolution Script
=====================================

Analyzes dependencies from extracted components and resolves conflicts with main codebase.
Creates consolidated requirements files and identifies any version conflicts.

Run this script from the repository root.
"""

import os
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple
from collections import defaultdict

def parse_requirements_file(file_path: str) -> Dict[str, str]:
    """Parse a requirements.txt file into package -> version mapping."""
    requirements = {}

    if not os.path.exists(file_path):
        return requirements

    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            # Handle -r requirements.txt includes
            if line.startswith('-r '):
                included_file = line[3:]
                included_path = os.path.join(os.path.dirname(file_path), included_file)
                included_reqs = parse_requirements_file(included_path)
                requirements.update(included_reqs)
                continue

            # Parse package==version or package>=version, etc.
            match = re.match(r'^([a-zA-Z0-9_-]+)([><=~!]+.+)?', line)
            if match:
                package = match.group(1).lower()
                version = match.group(2) if match.group(2) else ""
                requirements[package] = version

    return requirements

def compare_versions(version1: str, version2: str) -> str:
    """Compare two version specifiers and return the more restrictive one."""
    # Simple comparison - prefer the more specific version
    if not version1:
        return version2
    if not version2:
        return version1

    # If they're the same, return either
    if version1 == version2:
        return version1

    # Prefer exact versions (==) over ranges (>=, >, etc.)
    if '==' in version1 and '==' not in version2:
        return version1
    if '==' in version2 and '==' not in version1:
        return version2

    # For ranges, prefer the more restrictive one
    # This is a simplified approach - in practice you'd want more sophisticated version comparison
    return version1  # Default to first one

def resolve_conflicts(base_reqs: Dict[str, str], extracted_reqs: Dict[str, str]) -> Tuple[Dict[str, str], List[str]]:
    """Resolve conflicts between base and extracted requirements."""
    resolved = dict(base_reqs)  # Start with base requirements
    conflicts = []

    for package, extracted_version in extracted_reqs.items():
        if package in resolved:
            base_version = resolved[package]
            if base_version != extracted_version:
                resolved_version = compare_versions(base_version, extracted_version)
                resolved[package] = resolved_version
                conflicts.append(f"âš ï¸  {package}: {base_version} vs {extracted_version} â†’ {resolved_version}")
        else:
            resolved[package] = extracted_version

    return resolved, conflicts

def generate_updated_requirements(resolved_reqs: Dict[str, str], output_file: str):
    """Generate updated requirements.txt file."""
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Dream.os - Consolidated Requirements\n")
        f.write("# Includes dependencies from extracted systems (Wave C)\n")
        f.write("# Generated by phase2_dependency_resolution.py\n\n")

        # Group packages by category for better organization
        categories = {
            "Core Runtime": ["python-dotenv", "pyyaml", "pydantic", "requests", "aiohttp"],
            "GUI & Desktop": ["pyqt6", "pyqt6-sip"],
            "Web Scraping": ["selenium", "undetected-chromedriver", "beautifulsoup4"],
            "Template Engine": ["jinja2"],
            "Data Processing": ["pandas", "numpy", "openpyxl"],
            "Machine Learning": ["torch", "transformers", "peft", "datasets", "evaluate", "accelerate", "sentence-transformers"],
            "Vector Search": ["faiss-cpu", "scikit-learn"],
            "Web Framework": ["flask", "flask-cors"],
            "Monitoring": ["prometheus-client"],
            "Communication": ["discord.py"],
            "Development": ["black", "flake8", "pytest", "mypy", "pylint"],
            "Utilities": ["python-dateutil", "pytz", "loguru", "pyotp", "jsonschema", "typer", "rich", "webdriver-manager", "reportlab"]
        }

        written_packages = set()

        for category, packages in categories.items():
            category_packages = []
            for package in packages:
                if package in resolved_reqs and package not in written_packages:
                    version = resolved_reqs[package]
                    if version:
                        category_packages.append(f"{package}{version}")
                    else:
                        category_packages.append(package)
                    written_packages.add(package)

            if category_packages:
                f.write(f"\n# {category}\n")
                for req in sorted(category_packages):
                    f.write(f"{req}\n")

        # Add any remaining packages not in categories
        remaining = []
        for package, version in resolved_reqs.items():
            if package not in written_packages:
                if version:
                    remaining.append(f"{package}{version}")
                else:
                    remaining.append(package)

        if remaining:
            f.write("\n# Additional Dependencies\n")
            for req in sorted(remaining):
                f.write(f"{req}\n")

def main():
    """Main dependency resolution function."""
    print("ğŸ”§ Phase 2: Dependency Resolution")
    print("=" * 40)

    # Load base requirements
    base_reqs = parse_requirements_file('requirements.txt')
    print(f"ğŸ“¦ Base requirements: {len(base_reqs)} packages")

    # Load extracted system requirements
    extracted_reqs = {}

    # Dreamscape requirements
    dreamscape_reqs = parse_requirements_file('archive/dreamscape_project/Thea/requirements.txt')
    extracted_reqs.update(dreamscape_reqs)
    print(f"ğŸ“¦ Dreamscape requirements: {len(dreamscape_reqs)} packages")

    # Lead harvester requirements (check if exists)
    lead_reqs_file = 'archive/lead_harvester/requirements.txt'
    if os.path.exists(lead_reqs_file):
        lead_reqs = parse_requirements_file(lead_reqs_file)
        extracted_reqs.update(lead_reqs)
        print(f"ğŸ“¦ Lead harvester requirements: {len(lead_reqs)} packages")
    else:
        print("ğŸ“¦ Lead harvester: No separate requirements file found")

    # Resolve conflicts
    resolved_reqs, conflicts = resolve_conflicts(base_reqs, extracted_reqs)

    print(f"\nğŸ“Š Resolution Results:")
    print(f"Total unique packages: {len(resolved_reqs)}")
    print(f"New packages added: {len(extracted_reqs) - len(set(extracted_reqs.keys()) & set(base_reqs.keys()))}")
    print(f"Version conflicts resolved: {len(conflicts)}")

    if conflicts:
        print("\nâš ï¸  Version Conflicts Resolved:")
        for conflict in conflicts:
            print(f"  {conflict}")

    # Generate updated requirements file
    output_file = 'requirements-consolidated.txt'
    generate_updated_requirements(resolved_reqs, output_file)

    print(f"\nâœ… Generated consolidated requirements: {output_file}")

    # Summary
    print("\n" + "=" * 40)
    print("ğŸ“‹ DEPENDENCY RESOLUTION COMPLETE")
    print("\nNext steps:")
    print("1. Review requirements-consolidated.txt")
    print("2. Test installation: pip install -r requirements-consolidated.txt")
    print("3. Run integration tests")
    print("4. Update CI/CD to use consolidated requirements")

if __name__ == "__main__":
    main()