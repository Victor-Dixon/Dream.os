from pathlib import Path
import json
import os
import sys

import numpy as np
import pytest

from src.services.multimedia.content_management_service import ContentManagementService
from src.services.multimedia.media_processor_service import MediaProcessorService
from src.services.multimedia.streaming_service import StreamingService
from src.utils.stability_improvements import stability_manager, safe_import
from unittest.mock import Mock, patch, MagicMock
import time

#!/usr/bin/env python3
"""
Multimedia Integration Test Suite
Comprehensive testing of all multimedia services with TDD methodology
"""



# Add parent directory to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "..", ".."))



class TestMultimediaIntegration:
    """Integration test suite for multimedia services"""

    @pytest.fixture
    def media_processor(self):
        """Create a fresh MediaProcessorService instance"""
        return MediaProcessorService()

    @pytest.fixture
    def content_manager(self):
        """Create a fresh ContentManagementService instance"""
        return ContentManagementService()

    @pytest.fixture
    def streaming_service(self):
        """Create a fresh StreamingService instance"""
        return StreamingService()

    @pytest.fixture
    def mock_frame(self):
        """Create a mock video frame for testing"""
        return np.random.randint(0, 255, (480, 640, 3), dtype=np.uint8)

    @pytest.fixture
    def mock_audio_data(self):
        """Create mock audio data for testing"""
        return np.random.randint(-32768, 32767, 1024, dtype=np.int16)

    def test_media_processor_initialization(self, media_processor):
        """Test MediaProcessorService initialization"""
        assert media_processor.video_service is not None
        assert media_processor.audio_service is not None
        assert media_processor.processing_pipelines == {}
        assert media_processor.effect_chains == {}
        assert media_processor.is_processing == False

    def test_content_manager_initialization(self, content_manager):
        """Test ContentManagementService initialization"""
        assert content_manager.content_pipelines == {}
        assert content_manager.content_templates == {}
        assert content_manager.auto_blogger_config["enabled"] == True
        assert content_manager.content_cache == {}

    def test_streaming_service_initialization(self, streaming_service):
        """Test StreamingService initialization"""
        assert streaming_service.streaming_sessions == {}
        assert streaming_service.content_schedules == {}
        assert streaming_service.streaming_config["max_streams"] == 5
        assert streaming_service.streaming_config["default_quality"] == "720p"

    def test_multimedia_pipeline_creation(self, media_processor):
        """Test multimedia pipeline creation and management"""
        # Create pipeline configuration
        pipeline_config = {
            "name": "test_pipeline",
            "type": "multimedia",
            "enable_video": True,
            "enable_audio": True,
            "video": {"device_id": 0},
            "audio": {"device_id": 0},
            "video_effects": [{"type": "grayscale"}],
            "audio_effects": [{"type": "normalize"}],
        }

        # Start pipeline
        result = media_processor.start_multimedia_pipeline(
            "test_pipeline", pipeline_config
        )
        assert result == True

        # Check pipeline status
        status = media_processor.get_pipeline_status("test_pipeline")
        assert status["name"] == "test_pipeline"
        assert status["status"] == "active"

        # Stop pipeline
        result = media_processor.stop_multimedia_pipeline("test_pipeline")
        assert result == True

    def test_content_pipeline_creation(self, content_manager):
        """Test content pipeline creation and execution"""
        # Create content pipeline
        pipeline_config = {
            "name": "blog_pipeline",
            "type": "blog",
            "source": "multimedia",
            "output_format": "markdown",
        }

        result = content_manager.create_content_pipeline(
            "blog_pipeline", pipeline_config
        )
        assert result == True

        # Start content generation
        source_data = {
            "title": "Test Blog Post",
            "description": "A test blog post generated by Auto Blogger",
            "tags": ["test", "automation", "ai"],
            "category": "technology",
            "key_points": ["Point 1", "Point 2", "Point 3"],
            "summary": "This is a test summary.",
        }

        result = content_manager.start_content_generation("blog_pipeline", source_data)
        assert result == True

        # Wait for generation to complete
        time.sleep(0.1)

        # Check pipeline status
        status = content_manager.get_pipeline_status("blog_pipeline")
        assert status["status"] == "completed"
        assert status["statistics"]["total_generated"] > 0

    def test_streaming_session_management(self, streaming_service):
        """Test streaming session creation and management"""
        # Create streaming configuration
        stream_config = {
            "name": "test_stream",
            "source": "webcam",
            "platforms": ["youtube", "twitch"],
            "quality": "720p",
            "fps": 30,
        }

        # Start live stream
        result = streaming_service.start_live_stream("test_stream", stream_config)
        assert result == True

        # Check streaming status
        status = streaming_service.get_streaming_status("test_stream")
        assert status["status"] == "live"
        assert "youtube" in status["platforms"]
        assert "twitch" in status["platforms"]

        # Update stream quality
        result = streaming_service.update_stream_quality("test_stream", "1080p")
        assert result == True

        # Stop stream
        result = streaming_service.stop_live_stream("test_stream")
        assert result == True

    def test_content_scheduling(self, streaming_service):
        """Test content scheduling functionality"""
        # Create schedule configuration
        schedule_config = {
            "name": "daily_content",
            "content": "daily_update",
            "schedule_type": "daily",
            "platforms": ["youtube"],
            "hour": 9,
            "minute": 0,
        }

        # Create schedule
        result = streaming_service.schedule_content("daily_content", schedule_config)
        assert result == True

        # Check schedule status
        status = streaming_service.get_schedule_status("daily_content")
        assert status["status"] == "scheduled"
        assert status["config"]["schedule_type"] == "daily"

    def test_effect_chain_creation(self, media_processor):
        """Test effect chain creation and application"""
        # Create video effect chain
        video_effects = [
            {"type": "grayscale"},
            {"type": "blur", "params": {"kernel_size": 5}},
            {"type": "edge_detection"},
        ]

        result = media_processor.create_effect_chain("video_chain", video_effects)
        assert result == True

        # Create audio effect chain
        audio_effects = [
            {"type": "normalize"},
            {"type": "echo", "params": {"delay": 0.1, "decay": 0.5}},
        ]

        result = media_processor.create_effect_chain("audio_chain", audio_effects)
        assert result == True

        # Check effect chains
        assert "video_chain" in media_processor.effect_chains
        assert "audio_chain" in media_processor.effect_chains
        assert len(media_processor.effect_chains["video_chain"]["effects"]) == 3
        assert len(media_processor.effect_chains["audio_chain"]["effects"]) == 2

    def test_multimedia_pipeline_with_effects(self, media_processor):
        """Test multimedia pipeline with effect chains"""
        # Create effect chains first
        video_effects = [{"type": "grayscale"}]
        audio_effects = [{"type": "normalize"}]

        media_processor.create_effect_chain("test_video_chain", video_effects)
        media_processor.create_effect_chain("test_audio_chain", audio_effects)

        # Create pipeline with effects
        pipeline_config = {
            "name": "effects_pipeline",
            "type": "multimedia",
            "enable_video": True,
            "enable_audio": True,
            "video": {"device_id": 0},
            "audio": {"device_id": 0},
            "video_effects": video_effects,
            "audio_effects": audio_effects,
        }

        # Start pipeline
        result = media_processor.start_multimedia_pipeline(
            "effects_pipeline", pipeline_config
        )
        assert result == True

        # Check pipeline status
        status = media_processor.get_pipeline_status("effects_pipeline")
        assert status["status"] == "active"

        # Stop pipeline
        media_processor.stop_multimedia_pipeline("effects_pipeline")

    def test_content_quality_calculation(self, content_manager):
        """Test content quality scoring system"""
        # Test high-quality content
        high_quality_content = {
            "title": "High Quality Title",
            "description": "Comprehensive description",
            "content": "Detailed content with substantial information",
            "tags": ["tag1", "tag2", "tag3"],
            "category": "technology",
            "format": "markdown",
            "created_date": "2025-01-01T00:00:00",
        }

        quality_score = content_manager._calculate_content_quality(high_quality_content)
        assert quality_score >= 0.8

        # Test low-quality content
        low_quality_content = {
            "title": "",
            "description": "",
            "content": "",
            "tags": [],
            "category": "",
            "format": "",
            "created_date": "",
        }

        quality_score = content_manager._calculate_content_quality(low_quality_content)
        assert quality_score <= 0.3

    def test_streaming_quality_presets(self, streaming_service):
        """Test streaming quality preset management"""
        # Check available quality presets
        presets = streaming_service.streaming_config["quality_presets"]
        assert "1080p" in presets
        assert "720p" in presets
        assert "480p" in presets

        # Check preset specifications
        assert presets["1080p"]["width"] == 1920
        assert presets["1080p"]["height"] == 1080
        assert presets["1080p"]["bitrate"] == 5000

        assert presets["720p"]["width"] == 1280
        assert presets["720p"]["height"] == 720
        assert presets["720p"]["bitrate"] == 2500

    def test_content_pipeline_validation(self, content_manager):
        """Test content pipeline configuration validation"""
        # Test valid configuration
        valid_config = {
            "name": "valid_pipeline",
            "type": "blog",
            "source": "multimedia",
            "output_format": "markdown",
        }

        result = content_manager._validate_content_pipeline_config(valid_config)
        assert result == True

        # Test invalid configuration (missing required field)
        invalid_config = {
            "name": "invalid_pipeline",
            "type": "blog"
            # Missing 'source' and 'output_format'
        }

        result = content_manager._validate_content_pipeline_config(invalid_config)
        assert result == False

        # Test invalid content type
        invalid_type_config = {
            "name": "invalid_type",
            "type": "invalid_type",
            "source": "multimedia",
            "output_format": "markdown",
        }

        result = content_manager._validate_content_pipeline_config(invalid_type_config)
        assert result == False

    def test_streaming_config_validation(self, streaming_service):
        """Test streaming configuration validation"""
        # Test valid configuration
        valid_config = {
            "name": "valid_stream",
            "source": "webcam",
            "platforms": ["youtube", "twitch"],
        }

        result = streaming_service._validate_streaming_config(valid_config)
        assert result == True

        # Test invalid configuration (missing required field)
        invalid_config = {
            "name": "invalid_stream"
            # Missing 'source' and 'platforms'
        }

        result = streaming_service._validate_streaming_config(invalid_config)
        assert result == False

        # Test invalid platform
        invalid_platform_config = {
            "name": "invalid_platform",
            "source": "webcam",
            "platforms": ["invalid_platform"],
        }

        result = streaming_service._validate_streaming_config(invalid_platform_config)
        assert result == False

    def test_multimedia_system_status(self, media_processor):
        """Test overall multimedia system status reporting"""
        # Get system status
        status = media_processor.get_system_status()

        assert "system_status" in status
        assert "total_pipelines" in status
        assert "effect_chains" in status
        assert "video_service" in status
        assert "audio_service" in status
        assert "config" in status

        # Check video service status
        video_status = status["video_service"]
        assert "is_capturing" in video_status
        assert "active_captures" in video_status
        assert "devices" in video_status

        # Check audio service status
        audio_status = status["video_service"]
        assert "is_processing" in audio_status
        assert "active_streams" in audio_status
        assert "devices" in audio_status

    def test_content_cache_management(self, content_manager):
        """Test content cache operations"""
        # Check initial cache state
        cache_status = content_manager.get_content_cache()
        assert cache_status["total_cached"] == 0

        # Clear cache
        result = content_manager.clear_content_cache()
        assert result == True

        # Check cache after clearing
        cache_status = content_manager.get_content_cache()
        assert cache_status["total_cached"] == 0

    def test_streaming_statistics(self, streaming_service):
        """Test streaming statistics collection"""
        # Get streaming statistics
        stats = streaming_service.get_streaming_statistics()

        assert "total_streams" in stats
        assert "live_streams" in stats
        assert "total_viewers" in stats
        assert "total_frames_sent" in stats
        assert "total_errors" in stats
        assert "error_rate" in stats
        assert "uptime" in stats

        # Check initial values
        assert stats["total_streams"] == 0
        assert stats["live_streams"] == 0
        assert stats["total_viewers"] == 0
        assert stats["total_frames_sent"] == 0
        assert stats["total_errors"] == 0
        assert stats["error_rate"] == 0.0

    def test_error_handling(self, media_processor, content_manager, streaming_service):
        """Test error handling across all services"""
        # Test media processor error handling
        try:
            # Try to start pipeline with invalid config
            result = media_processor.start_multimedia_pipeline("error_test", {})
            assert result == False
        except Exception:
            pytest.fail("MediaProcessorService should handle invalid config gracefully")

        # Test content manager error handling
        try:
            # Try to create pipeline with invalid config
            result = content_manager.create_content_pipeline("error_test", {})
            assert result == False
        except Exception:
            pytest.fail(
                "ContentManagementService should handle invalid config gracefully"
            )

        # Test streaming service error handling
        try:
            # Try to start stream with invalid config
            result = streaming_service.start_live_stream("error_test", {})
            assert result == False
        except Exception:
            pytest.fail("StreamingService should handle invalid config gracefully")


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
